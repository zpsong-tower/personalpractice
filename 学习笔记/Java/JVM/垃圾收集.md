## 垃圾收集

### ~~引用计数算法~~

核心思路：对象每被一个地方引用，计数器加一，引用失效则减一，计数器为零时证明此对象不可能再被使用

主流Java虚拟机并没有选择该算法来管理内存

该算法必须配合大量额外处理才能保证正确地工作，譬如对象之间相互循环引用的问题

### 可达性分析算法

核心思路：通过一系列**根对象**作为起始节点集，根据引用关系向下搜索，如果某个对象到根对象间没有任何引用链相连，则证明此对象不可能再被使用

在Java技术体系里面**根对象**一般包括以下几种：

> - 虚拟机栈（栈帧中的本地变量表）中引用的对象
>     - 譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
> - 在方法区中类静态属性引用的对象
>     - 譬如Java类的引用类型静态变量
> - 在方法区中常量引用的对象
>     - 譬如字符串常量池里的引用
> - 在本地方法栈中Native方法引用的对象
> - Java虚拟机内部的引用
>     - 譬如基本数据类型对应的Class对象
>     - 譬如一些常驻的一场对象（NullPointException、OutOfMemoryError等）
>     - 譬如系统类加载器
> - 所有被同步锁（synchronized 关键字）持有的对象
> - 反应Java虚拟机内部情况的部分对象

根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时被视作**根对象**，譬如分代收集和局部回收

### 引用扩展

**强引用**：

- 使用最普遍的引用

- 无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象

**软引用**：

- 非必须的对象，但还有用
- 在系统将要发生OOM前，会把只被软引用关联着的对象列入回收范围进行第二次回收

**弱引用**：

- 非必须对象，比软引用更弱
- 被弱引用关联的对象只能生存到下一次垃圾收集发生为止

**虚引用**：

- 仅为了能在对象被回收时收到一个系统通知，最弱的引用
- 虚引用完全不会对其生存时间构成影响，无法通过虚引用来取得一个对象的实例

### ~~finalize()~~

任何一个对象的 `finalize()` 方法都只会被系统自动调用一次，如果对象面临下一次回收，则不会被执行

并不等同于析构函数，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，应尽量避免使用

`finalize()` 能做的所有工作，使用try-finally或其他方式可以做得更好、更及时

### 回收方法区

即回收废弃常量和不再使用的类型

Java虚拟机被允许对满足以下条件的无用常量及类型进行回收：

**常量**：

- 曾进入常量池，但当前系统又没有任何一个对象的值为该常量

**类型**：

- 该类所有的实例都已经被回收
- 加载该类的类加载器已经被回收
- 该类对应的Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

### 分代收集理论

收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储

1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数